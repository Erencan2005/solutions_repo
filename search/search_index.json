{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Deriving the Governing Equations The motion of a projectile can be described by applying Newton's second law. For a projectile launched from an initial position with velocity \\(v_0\\) at an angle \\(\\theta\\) with respect to the horizontal, we have: In the horizontal direction (x-axis): \\( \\(\\frac{d^2x}{dt^2} = 0\\) \\) In the vertical direction (y-axis): \\( \\(\\frac{d^2y}{dt^2} = -g\\) \\) Where \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2 on Earth). Integrating these equations with respect to time with initial conditions: - \\(x(0) = 0\\) - \\(y(0) = h\\) (initial height) - \\(v_x(0) = v_0\\cos(\\theta)\\) - \\(v_y(0) = v_0\\sin(\\theta)\\) We obtain: \\[x(t) = (v_0\\cos\\theta)t$$ $$y(t) = h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2\\] These parametric equations describe the position of the projectile at any time \\(t\\) . Family of Solutions The family of solutions is defined by varying the parameters: - Initial velocity ( \\(v_0\\) ) - Launch angle ( \\(\\theta\\) ) - Initial height ( \\(h\\) ) - Gravitational acceleration ( \\(g\\) ) Each combination of these parameters produces a unique trajectory. 2. Analysis of the Range Range Equation The range \\(R\\) is the horizontal distance traveled when the projectile returns to its initial height. To find this, we need to determine when \\(y(t) = h\\) : \\[h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = h\\] Simplifying: \\( \\((v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = 0\\) \\) This equation has two solutions: \\(t = 0\\) and \\(t = \\frac{2v_0\\sin\\theta}{g}\\) The second solution gives us the time of flight. The range is then: \\[R = (v_0\\cos\\theta) \\cdot \\frac{2v_0\\sin\\theta}{g} = \\frac{v_0^2\\sin(2\\theta)}{g}\\] This demonstrates that the range is proportional to: - The square of the initial velocity - The sine of twice the angle of projection - Inversely proportional to the gravitational acceleration Optimal Angle for Maximum Range To find the angle that maximizes the range, we differentiate with respect to \\(\\theta\\) and set it equal to zero: \\[\\frac{dR}{d\\theta} = \\frac{v_0^2\\cos(2\\theta)}{g} = 0\\] This gives us \\(\\cos(2\\theta) = 0\\) , thus \\(2\\theta = \\frac{\\pi}{2}\\) or \\(\\theta = \\frac{\\pi}{4} = 45\u00b0\\) Therefore, in the absence of air resistance and with a level landing surface, the maximum range is achieved at a 45\u00b0 angle. Effect of Initial Height If the projectile is launched from a height \\(h\\) above the landing surface, the range equation becomes more complex: \\[R = v_0\\cos\\theta \\cdot t_{landing}\\] Where \\(t_{landing}\\) is the time when the projectile reaches the ground level ( \\(y = 0\\) ): \\[h + (v_0\\sin\\theta)t_{landing} - \\frac{1}{2}gt_{landing}^2 = 0\\] Solving this quadratic equation: \\[t_{landing} = \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] This means that the range now depends on the initial height as well: \\[R = v_0\\cos\\theta \\cdot \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] 3. Practical Applications Real-world Considerations In practice, projectile motion is influenced by: - Air resistance (drag) - Wind - Varying gravitational field - Rotating reference frames (Coriolis effect) - Non-uniform terrain Incorporating Air Resistance A simple model for air resistance is to include a drag force proportional to velocity: \\[F_d = -bv\\] This leads to a modified set of differential equations: \\[\\frac{d^2x}{dt^2} = -\\frac{b}{m}v_x$$ $$\\frac{d^2y}{dt^2} = -g - \\frac{b}{m}v_y\\] Where \\(b\\) is the drag coefficient and \\(m\\) is the mass of the projectile. These equations typically require numerical methods to solve. 4. pyhton Implementation","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-the-governing-equations","text":"The motion of a projectile can be described by applying Newton's second law. For a projectile launched from an initial position with velocity \\(v_0\\) at an angle \\(\\theta\\) with respect to the horizontal, we have: In the horizontal direction (x-axis): \\( \\(\\frac{d^2x}{dt^2} = 0\\) \\) In the vertical direction (y-axis): \\( \\(\\frac{d^2y}{dt^2} = -g\\) \\) Where \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2 on Earth). Integrating these equations with respect to time with initial conditions: - \\(x(0) = 0\\) - \\(y(0) = h\\) (initial height) - \\(v_x(0) = v_0\\cos(\\theta)\\) - \\(v_y(0) = v_0\\sin(\\theta)\\) We obtain: \\[x(t) = (v_0\\cos\\theta)t$$ $$y(t) = h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2\\] These parametric equations describe the position of the projectile at any time \\(t\\) .","title":"Deriving the Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The family of solutions is defined by varying the parameters: - Initial velocity ( \\(v_0\\) ) - Launch angle ( \\(\\theta\\) ) - Initial height ( \\(h\\) ) - Gravitational acceleration ( \\(g\\) ) Each combination of these parameters produces a unique trajectory.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to its initial height. To find this, we need to determine when \\(y(t) = h\\) : \\[h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = h\\] Simplifying: \\( \\((v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = 0\\) \\) This equation has two solutions: \\(t = 0\\) and \\(t = \\frac{2v_0\\sin\\theta}{g}\\) The second solution gives us the time of flight. The range is then: \\[R = (v_0\\cos\\theta) \\cdot \\frac{2v_0\\sin\\theta}{g} = \\frac{v_0^2\\sin(2\\theta)}{g}\\] This demonstrates that the range is proportional to: - The square of the initial velocity - The sine of twice the angle of projection - Inversely proportional to the gravitational acceleration","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle-for-maximum-range","text":"To find the angle that maximizes the range, we differentiate with respect to \\(\\theta\\) and set it equal to zero: \\[\\frac{dR}{d\\theta} = \\frac{v_0^2\\cos(2\\theta)}{g} = 0\\] This gives us \\(\\cos(2\\theta) = 0\\) , thus \\(2\\theta = \\frac{\\pi}{2}\\) or \\(\\theta = \\frac{\\pi}{4} = 45\u00b0\\) Therefore, in the absence of air resistance and with a level landing surface, the maximum range is achieved at a 45\u00b0 angle.","title":"Optimal Angle for Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-height","text":"If the projectile is launched from a height \\(h\\) above the landing surface, the range equation becomes more complex: \\[R = v_0\\cos\\theta \\cdot t_{landing}\\] Where \\(t_{landing}\\) is the time when the projectile reaches the ground level ( \\(y = 0\\) ): \\[h + (v_0\\sin\\theta)t_{landing} - \\frac{1}{2}gt_{landing}^2 = 0\\] Solving this quadratic equation: \\[t_{landing} = \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] This means that the range now depends on the initial height as well: \\[R = v_0\\cos\\theta \\cdot \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\]","title":"Effect of Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-considerations","text":"In practice, projectile motion is influenced by: - Air resistance (drag) - Wind - Varying gravitational field - Rotating reference frames (Coriolis effect) - Non-uniform terrain","title":"Real-world Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#incorporating-air-resistance","text":"A simple model for air resistance is to include a drag force proportional to velocity: \\[F_d = -bv\\] This leads to a modified set of differential equations: \\[\\frac{d^2x}{dt^2} = -\\frac{b}{m}v_x$$ $$\\frac{d^2y}{dt^2} = -g - \\frac{b}{m}v_y\\] Where \\(b\\) is the drag coefficient and \\(m\\) is the mass of the projectile. These equations typically require numerical methods to solve.","title":"Incorporating Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-pyhton-implementation","text":"","title":"4. pyhton Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small-Angle Oscillations For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed. 2. Analysis of Dynamics Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams. 3. Practical Applications Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits. 4. Implementation Computational Model Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() Visualization Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior. Deliverables Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics. Hints and Resources Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angle-oscillations","text":"For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations.","title":"Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization","text":"Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior.","title":"Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task Derive the Relationship : Derive the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. Astronomical Implications : Discuss the implications of this relationship for astronomy, including its role in calculating planetary masses and distances. Real-World Examples : Analyze real-world examples, such as the Moon's orbit around Earth or the orbits of planets in the Solar System. Computational Model : Implement a computational model to simulate circular orbits and verify the relationship. Derivation of Kepler's Third Law For a small body orbiting a much larger body in a circular orbit, Newton's law of gravitation and centripetal force provide: [ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} ] where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius, - \\( v \\) is the orbital velocity. Since the orbital velocity is given by: [ v = \\frac{2 \\pi r}{T} ] substituting this into the force equation: [ \\frac{G M}{r^2} = \\frac{4 \\pi^2 r}{T^2} ] Rearranging to express \\( T^2 \\) in terms of \\( r^3 \\) : [ T^2 = \\frac{4 \\pi^2}{G M} r^3 ] This confirms that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\) , which is Kepler\u2019s Third Law. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt def orbital_period(radius, mass_central): \"\"\" Calculate the orbital period using Kepler's Third Law. \"\"\" G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return 2 * np.pi * np.sqrt(radius**3 / (G * mass_central)) # Define constants mass_earth = 5.972e24 # kg mass_sun = 1.989e30 # kg radii = np.linspace(1e7, 1.5e11, 100) # Radius range (m) periods = [orbital_period(r, mass_sun) for r in radii] # Plot T^2 vs R^3 plt.figure(figsize=(8, 6)) plt.plot(radii**3, np.array(periods)**2, label='T^2 vs R^3') plt.xlabel(\"Orbital Radius^3 (m^3)\") plt.ylabel(\"Orbital Period^2 (s^2)\") plt.title(\"Kepler's Third Law: T^2 vs R^3\") plt.legend() plt.grid() plt.show() # Simulating a simple circular orbit def simulate_orbit(radius, time_steps, mass_central): \"\"\" Simulate a circular orbit around a central mass. \"\"\" omega = np.sqrt(6.67430e-11 * mass_central / radius**3) # Angular velocity times = np.linspace(0, 2 * np.pi / omega, time_steps) x = radius * np.cos(omega * times) y = radius * np.sin(omega * times) plt.figure(figsize=(6, 6)) plt.plot(x, y, label='Orbit Path') plt.scatter(0, 0, color='red', label='Central Body') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbit\") plt.legend() plt.grid() plt.axis('equal') plt.show() simulate_orbit(1.5e10, 1000, mass_sun) Discussion Astronomical Applications : Kepler's Third Law is used to determine planetary distances and masses. It aids in calculating the orbits of exoplanets using observed transit periods. Extensions to Elliptical Orbits : The law generalizes to elliptical orbits with the semi-major axis \\( a \\) replacing \\( r \\) . This principle is foundational for understanding celestial mechanics. This simulation and derivation provide a deeper understanding of Kepler\u2019s Third Law and its significance in astrophysics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Derive the Relationship : Derive the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. Astronomical Implications : Discuss the implications of this relationship for astronomy, including its role in calculating planetary masses and distances. Real-World Examples : Analyze real-world examples, such as the Moon's orbit around Earth or the orbits of planets in the Solar System. Computational Model : Implement a computational model to simulate circular orbits and verify the relationship.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a small body orbiting a much larger body in a circular orbit, Newton's law of gravitation and centripetal force provide: [ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} ] where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius, - \\( v \\) is the orbital velocity. Since the orbital velocity is given by: [ v = \\frac{2 \\pi r}{T} ] substituting this into the force equation: [ \\frac{G M}{r^2} = \\frac{4 \\pi^2 r}{T^2} ] Rearranging to express \\( T^2 \\) in terms of \\( r^3 \\) : [ T^2 = \\frac{4 \\pi^2}{G M} r^3 ] This confirms that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\) , which is Kepler\u2019s Third Law.","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt def orbital_period(radius, mass_central): \"\"\" Calculate the orbital period using Kepler's Third Law. \"\"\" G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return 2 * np.pi * np.sqrt(radius**3 / (G * mass_central)) # Define constants mass_earth = 5.972e24 # kg mass_sun = 1.989e30 # kg radii = np.linspace(1e7, 1.5e11, 100) # Radius range (m) periods = [orbital_period(r, mass_sun) for r in radii] # Plot T^2 vs R^3 plt.figure(figsize=(8, 6)) plt.plot(radii**3, np.array(periods)**2, label='T^2 vs R^3') plt.xlabel(\"Orbital Radius^3 (m^3)\") plt.ylabel(\"Orbital Period^2 (s^2)\") plt.title(\"Kepler's Third Law: T^2 vs R^3\") plt.legend() plt.grid() plt.show() # Simulating a simple circular orbit def simulate_orbit(radius, time_steps, mass_central): \"\"\" Simulate a circular orbit around a central mass. \"\"\" omega = np.sqrt(6.67430e-11 * mass_central / radius**3) # Angular velocity times = np.linspace(0, 2 * np.pi / omega, time_steps) x = radius * np.cos(omega * times) y = radius * np.sin(omega * times) plt.figure(figsize=(6, 6)) plt.plot(x, y, label='Orbit Path') plt.scatter(0, 0, color='red', label='Central Body') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbit\") plt.legend() plt.grid() plt.axis('equal') plt.show() simulate_orbit(1.5e10, 1000, mass_sun)","title":"Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion","text":"Astronomical Applications : Kepler's Third Law is used to determine planetary distances and masses. It aids in calculating the orbits of exoplanets using observed transit periods. Extensions to Elliptical Orbits : The law generalizes to elliptical orbits with the semi-major axis \\( a \\) replacing \\( r \\) . This principle is foundational for understanding celestial mechanics. This simulation and derivation provide a deeper understanding of Kepler\u2019s Third Law and its significance in astrophysics.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation: The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task: Define the first, second, and third cosmic velocities, explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration, including launching satellites, missions to other planets, and potential interstellar travel. Deliverables: A Markdown document with a Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Mathematical Formulation The first cosmic velocity ( \\(v_1\\) ), or orbital velocity, is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ The second cosmic velocity ( \\(v_2\\) ), or escape velocity, is: $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2GM}{R}} $$ The third cosmic velocity ( \\(v_3\\) ), the velocity needed to leave the star system, is given by: $$ v_3 = \\sqrt{2 \\frac{GM_{\\text{sun}}}{d}} $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ). - \\(M\\) is the mass of the celestial body. - \\(R\\) is the radius of the celestial body. - \\(M_{\\text{sun}}\\) is the mass of the Sun. - \\(d\\) is the distance from the Sun. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(mass, radius): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): return np.sqrt(2) * first_cosmic_velocity(mass, radius) def third_cosmic_velocity(mass_sun, distance): return np.sqrt(2 * 6.67430e-11 * mass_sun / distance) # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7), } # Compute velocities velocities = {} for body, (mass, radius) in bodies.items(): v1 = first_cosmic_velocity(mass, radius) v2 = second_cosmic_velocity(mass, radius) velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots() labels, v1_vals, v2_vals = zip(*[(k, v[0], v[1]) for k, v in velocities.items()]) x = np.arange(len(labels)) ax.bar(x - 0.2, v1_vals, 0.4, label=\"First Cosmic Velocity (m/s)\") ax.bar(x + 0.2, v2_vals, 0.4, label=\"Second Cosmic Velocity (m/s)\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Cosmic Velocities of Different Celestial Bodies\") ax.legend() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first, second, and third cosmic velocities, explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration, including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with a Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation","text":"The first cosmic velocity ( \\(v_1\\) ), or orbital velocity, is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ The second cosmic velocity ( \\(v_2\\) ), or escape velocity, is: $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2GM}{R}} $$ The third cosmic velocity ( \\(v_3\\) ), the velocity needed to leave the star system, is given by: $$ v_3 = \\sqrt{2 \\frac{GM_{\\text{sun}}}{d}} $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ). - \\(M\\) is the mass of the celestial body. - \\(R\\) is the radius of the celestial body. - \\(M_{\\text{sun}}\\) is the mass of the Sun. - \\(d\\) is the distance from the Sun.","title":"Mathematical Formulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(mass, radius): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): return np.sqrt(2) * first_cosmic_velocity(mass, radius) def third_cosmic_velocity(mass_sun, distance): return np.sqrt(2 * 6.67430e-11 * mass_sun / distance) # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7), } # Compute velocities velocities = {} for body, (mass, radius) in bodies.items(): v1 = first_cosmic_velocity(mass, radius) v2 = second_cosmic_velocity(mass, radius) velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots() labels, v1_vals, v2_vals = zip(*[(k, v[0], v[1]) for k, v in velocities.items()]) x = np.arange(len(labels)) ax.bar(x - 0.2, v1_vals, 0.4, label=\"First Cosmic Velocity (m/s)\") ax.bar(x + 0.2, v2_vals, 0.4, label=\"Second Cosmic Velocity (m/s)\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Cosmic Velocities of Different Celestial Bodies\") ax.legend() plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation: When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task: Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Mathematical Formulation The motion of the payload is governed by Newton's law of universal gravitation: $$ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} $$ This results in the following equations of motion: $$ \\frac{d^2 x}{dt^2} = -\\frac{GM}{r^3} x $$ $$ \\frac{d^2 y}{dt^2} = -\\frac{GM}{r^3} y $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ) - \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\ kg\\) ) - \\(r = \\sqrt{x^2 + y^2}\\) is the radial distance from Earth's center - \\((x, y)\\) are the coordinates of the payload Python Code for Simulation ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay] Initial conditions (altitude = 300 km, velocity = 7800 m/s tangentially) altitude = 300e3 x0, y0 = R_earth + altitude, 0 vx0, vy0 = 0, 7800 # m/s initial_state = [x0, y0, vx0, vy0] Time span for simulation time_span = (0, 6000) # 6000 seconds time_eval = np.linspace(*time_span, 1000) sol = solve_ivp(equations, time_span, initial_state, t_eval=time_eval, method='RK45') Extract results x_vals, y_vals = sol.y[0], sol.y[1] Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x_vals, y_vals, label=\"Payload Trajectory\") plt.plot(0, 0, 'ro', label=\"Earth\") Draw Earth earth_circle = plt.Circle((0, 0), R_earth, color='b', alpha=0.3, label=\"Earth Surface\") plt.gca().add_patch(earth_circle) plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-formulation","text":"The motion of the payload is governed by Newton's law of universal gravitation: $$ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} $$ This results in the following equations of motion: $$ \\frac{d^2 x}{dt^2} = -\\frac{GM}{r^3} x $$ $$ \\frac{d^2 y}{dt^2} = -\\frac{GM}{r^3} y $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ) - \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\ kg\\) ) - \\(r = \\sqrt{x^2 + y^2}\\) is the radial distance from Earth's center - \\((x, y)\\) are the coordinates of the payload","title":"Mathematical Formulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"def equations(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay]","title":"Equations of motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-altitude-300-km-velocity-7800-ms-tangentially","text":"altitude = 300e3 x0, y0 = R_earth + altitude, 0 vx0, vy0 = 0, 7800 # m/s initial_state = [x0, y0, vx0, vy0]","title":"Initial conditions (altitude = 300 km, velocity = 7800 m/s tangentially)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-span-for-simulation","text":"time_span = (0, 6000) # 6000 seconds time_eval = np.linspace(*time_span, 1000) sol = solve_ivp(equations, time_span, initial_state, t_eval=time_eval, method='RK45')","title":"Time span for simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#extract-results","text":"x_vals, y_vals = sol.y[0], sol.y[1]","title":"Extract results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-the-trajectory","text":"plt.figure(figsize=(8, 8)) plt.plot(x_vals, y_vals, label=\"Payload Trajectory\") plt.plot(0, 0, 'ro', label=\"Earth\")","title":"Plot the trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#draw-earth","text":"earth_circle = plt.Circle((0, 0), R_earth, color='b', alpha=0.3, label=\"Earth Surface\") plt.gca().add_patch(earth_circle) plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"Draw Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics. Problem Statement The task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. The waves will be described using the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k \\cdot r - \\omega \\cdot t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude of the wave. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number ( \\(\\lambda\\) is the wavelength). \\(\\omega = 2\\pi \\cdot f\\) is the angular frequency ( \\(f\\) is the frequency). \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source at \\((x_0, y_0)\\) to the point \\((x, y)\\) . \\(\\phi\\) is the initial phase. Steps to Follow 1. Select a Regular Polygon Choose a regular polygon, such as an equilateral triangle, square, or regular pentagon, for the placement of the point sources. 2. Position the Sources Place point wave sources at the vertices of the selected polygon. For example, for an equilateral triangle, there will be three sources, one at each vertex. 3. Wave Equations Write the equations describing the waves emitted from each source, considering their respective positions. 4. Superposition of Waves Apply the principle of superposition by summing the wave displacements at each point on the water surface. The displacement at any point \\((x, y)\\) on the surface is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\(N\\) is the number of sources (vertices of the polygon). 5. Analyze Interference Patterns Examine the resulting displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) as a function of position \\((x, y)\\) and time \\(t\\) . Identify regions of: - Constructive interference (wave amplification) - Destructive interference (wave cancellation) 6. Visualization Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Considerations: - Assume all sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . - The waves are coherent (i.e., they maintain a constant phase difference). Python Code for Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants A = 1 # amplitude lambda_ = 1 # wavelength f = 1 # frequency omega = 2 * np.pi * f # angular frequency k = 2 * np.pi / lambda_ # wave number phi = 0 # initial phase Function to compute the wave displacement at a given point (x, y) and time t def wave(x, y, x0, y0, t): r = np.sqrt((x - x0) 2 + (y - y0) 2) # distance from the source return A / np.sqrt(r) * np.cos(k * r - omega * t + phi) Function to compute the superposition of waves from multiple sources def superposition(x, y, sources, t): displacement = 0 for (x0, y0) in sources: displacement += wave(x, y, x0, y0, t) return displacement Create a grid of points on the water surface x_vals = np.linspace(-5, 5, 200) y_vals = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x_vals, y_vals) Define the number of sources and their positions for a regular polygon (e.g., hexagon) N = 6 # Number of sources (vertices of hexagon) radius = 2 # Radius of the circle on which the sources lie angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(angle), radius * np.sin(angle)) for angle in angles] Time variable for the wave motion t = 0.5 # Arbitrary time value for visualization Compute the displacement on the water surface due to superposition Z = np.vectorize(superposition)(X, Y, sources, t) Plot the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 20, cmap='jet') plt.colorbar(label='Displacement') plt.title('Interference Pattern on Water Surface (t = 0.5)') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"The task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. The waves will be described using the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k \\cdot r - \\omega \\cdot t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude of the wave. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number ( \\(\\lambda\\) is the wavelength). \\(\\omega = 2\\pi \\cdot f\\) is the angular frequency ( \\(f\\) is the frequency). \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source at \\((x_0, y_0)\\) to the point \\((x, y)\\) . \\(\\phi\\) is the initial phase.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"Choose a regular polygon, such as an equilateral triangle, square, or regular pentagon, for the placement of the point sources.","title":"1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"Place point wave sources at the vertices of the selected polygon. For example, for an equilateral triangle, there will be three sources, one at each vertex.","title":"2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equations","text":"Write the equations describing the waves emitted from each source, considering their respective positions.","title":"3. Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"Apply the principle of superposition by summing the wave displacements at each point on the water surface. The displacement at any point \\((x, y)\\) on the surface is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\(N\\) is the number of sources (vertices of the polygon).","title":"4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-interference-patterns","text":"Examine the resulting displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) as a function of position \\((x, y)\\) and time \\(t\\) . Identify regions of: - Constructive interference (wave amplification) - Destructive interference (wave cancellation)","title":"5. Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualization","text":"Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Considerations: - Assume all sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . - The waves are coherent (i.e., they maintain a constant phase difference).","title":"6. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-for-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Code for Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#constants","text":"A = 1 # amplitude lambda_ = 1 # wavelength f = 1 # frequency omega = 2 * np.pi * f # angular frequency k = 2 * np.pi / lambda_ # wave number phi = 0 # initial phase","title":"Constants"},{"location":"1%20Physics/3%20Waves/Problem_1/#function-to-compute-the-wave-displacement-at-a-given-point-x-y-and-time-t","text":"def wave(x, y, x0, y0, t): r = np.sqrt((x - x0) 2 + (y - y0) 2) # distance from the source return A / np.sqrt(r) * np.cos(k * r - omega * t + phi)","title":"Function to compute the wave displacement at a given point (x, y) and time t"},{"location":"1%20Physics/3%20Waves/Problem_1/#function-to-compute-the-superposition-of-waves-from-multiple-sources","text":"def superposition(x, y, sources, t): displacement = 0 for (x0, y0) in sources: displacement += wave(x, y, x0, y0, t) return displacement","title":"Function to compute the superposition of waves from multiple sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#create-a-grid-of-points-on-the-water-surface","text":"x_vals = np.linspace(-5, 5, 200) y_vals = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x_vals, y_vals)","title":"Create a grid of points on the water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#define-the-number-of-sources-and-their-positions-for-a-regular-polygon-eg-hexagon","text":"N = 6 # Number of sources (vertices of hexagon) radius = 2 # Radius of the circle on which the sources lie angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(angle), radius * np.sin(angle)) for angle in angles]","title":"Define the number of sources and their positions for a regular polygon (e.g., hexagon)"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-variable-for-the-wave-motion","text":"t = 0.5 # Arbitrary time value for visualization","title":"Time variable for the wave motion"},{"location":"1%20Physics/3%20Waves/Problem_1/#compute-the-displacement-on-the-water-surface-due-to-superposition","text":"Z = np.vectorize(superposition)(X, Y, sources, t)","title":"Compute the displacement on the water surface due to superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#plot-the-interference-pattern","text":"plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 20, cmap='jet') plt.colorbar(label='Displacement') plt.title('Interference Pattern on Water Surface (t = 0.5)') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Plot the interference pattern"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \ud83d\udcd8 Simulating the Effects of the Lorentz Force \ud83c\udfaf Objective To simulate the trajectory of a charged particle under the influence of electric and magnetic fields using the Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\(\\vec{F}\\) is the Lorentz force \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field \\(\\vec{v}\\) is the velocity of the particle \\(\\vec{B}\\) is the magnetic field \ud83e\uddea Simulation Scenarios Magnetic field only ( \\(\\vec{E} = 0\\) ) Combined electric and magnetic fields Crossed electric and magnetic fields \u2699\ufe0f Parameters Particle charge: \\(q = 1.0\\,\\mathrm{C}\\) Particle mass: \\(m = 1.0\\,\\mathrm{kg}\\) Initial position: \\(\\vec{r}_0 = (0, 0, 0)\\) Initial velocity: \\(\\vec{v}_0 = (1, 1, 0)\\) Magnetic field: \\(\\vec{B} = (0, 0, 1)\\,\\mathrm{T}\\) Electric field: configurable \ud83d\udcc8 Deliverables Plot of particle trajectory in 3D Visual exploration of how \\(\\vec{E}\\) , \\(\\vec{B}\\) , \\(q\\) , \\(m\\) , and \\(\\vec{v}_0\\) affect motion Discussion on physical phenomena (Larmor radius, drift velocity) \ud83e\udde0 Methods Euler\u2019s method for numerical integration 3D plotting using matplotlib \ud83d\udc0d Python Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge in Coulombs m = 1.0 # mass in kilograms # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field vector (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field vector (T) # Initial conditions r = np.array([0.0, 0.0, 0.0]) # Initial position (m) v = np.array([1.0, 1.0, 0.0]) # Initial velocity (m/s) # Time parameters dt = 0.01 # time step (s) steps = 1000 # total steps # Initialize array to store trajectory trajectory = np.zeros((steps, 3)) # Euler integration loop for i in range(steps): trajectory[i] = r F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v += a * dt # Update velocity r += v * dt # Update position # Plotting fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Charged Particle Trajectory under Lorentz Force') ax.legend() plt.show() \ud83d\udd04 Extensions Replace Euler method with Runge-Kutta for better accuracy Simulate non-uniform fields Include relativistic corrections at high speeds","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"\ud83d\udcd8 Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#objective","text":"To simulate the trajectory of a charged particle under the influence of electric and magnetic fields using the Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\(\\vec{F}\\) is the Lorentz force \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field \\(\\vec{v}\\) is the velocity of the particle \\(\\vec{B}\\) is the magnetic field","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-scenarios","text":"Magnetic field only ( \\(\\vec{E} = 0\\) ) Combined electric and magnetic fields Crossed electric and magnetic fields","title":"\ud83e\uddea Simulation Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Particle charge: \\(q = 1.0\\,\\mathrm{C}\\) Particle mass: \\(m = 1.0\\,\\mathrm{kg}\\) Initial position: \\(\\vec{r}_0 = (0, 0, 0)\\) Initial velocity: \\(\\vec{v}_0 = (1, 1, 0)\\) Magnetic field: \\(\\vec{B} = (0, 0, 1)\\,\\mathrm{T}\\) Electric field: configurable","title":"\u2699\ufe0f Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"Plot of particle trajectory in 3D Visual exploration of how \\(\\vec{E}\\) , \\(\\vec{B}\\) , \\(q\\) , \\(m\\) , and \\(\\vec{v}_0\\) affect motion Discussion on physical phenomena (Larmor radius, drift velocity)","title":"\ud83d\udcc8 Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#methods","text":"Euler\u2019s method for numerical integration 3D plotting using matplotlib","title":"\ud83e\udde0 Methods"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge in Coulombs m = 1.0 # mass in kilograms # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field vector (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field vector (T) # Initial conditions r = np.array([0.0, 0.0, 0.0]) # Initial position (m) v = np.array([1.0, 1.0, 0.0]) # Initial velocity (m/s) # Time parameters dt = 0.01 # time step (s) steps = 1000 # total steps # Initialize array to store trajectory trajectory = np.zeros((steps, 3)) # Euler integration loop for i in range(steps): trajectory[i] = r F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v += a * dt # Update velocity r += v * dt # Update position # Plotting fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Charged Particle Trajectory under Lorentz Force') ax.legend() plt.show()","title":"\ud83d\udc0d Python Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Replace Euler method with Runge-Kutta for better accuracy Simulate non-uniform fields Include relativistic corrections at high speeds","title":"\ud83d\udd04 Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"\ud83d\udd0c Circuits Problem 1 Equivalent Resistance Using Graph Theory \ud83e\udde0 Motivation Calculating the equivalent resistance of a complex circuit is essential in circuit analysis. Traditional methods of reducing series and parallel resistors work for small circuits but become cumbersome with larger networks. Graph theory allows us to represent circuits as graphs: - Nodes : Electrical junctions - Edges : Resistors (with weights representing resistance) This method enables a systematic and automated reduction process, suitable for simulation and optimization. \ud83d\udee0\ufe0f Option 1: Algorithm Description We aim to simplify the circuit iteratively using graph-theoretical principles. \ud83d\udcc8 Graph Representation Given a circuit graph \\( G = (V, E) \\) : \\( V \\) : set of nodes (junctions) \\( E \\) : set of edges (resistors), each with a weight \\( R_e \\) \ud83d\udd01 Algorithm Overview While the graph has more than two nodes: Identify series and parallel connections. Replace them with their equivalent resistance. Return the resistance between the source and destination nodes. \u2699\ufe0f Pseudocode function simplify_circuit(graph, source, target): while graph has more than 2 nodes: for each node v in graph: if v has degree 2 and not in [source, target]: # Series reduction u, w = neighbors of v R1 = resistance(u, v) R2 = resistance(v, w) R_eq = R1 + R2 remove v and its edges add edge (u, w) with resistance R_eq for each pair of nodes (u, v): if multiple edges exist between u and v: # Parallel reduction resistances = [R1, R2, ..., Rn] R_eq = 1 / sum(1/R for R in resistances) remove all parallel edges add edge (u, v) with resistance R_eq return resistance between source and target \ud83e\uddee Formulas Series : If resistors \\( R_1 \\) and \\( R_2 \\) are in series: $$ R_{\\text{eq}} = R_1 + R_2 $$ Parallel : If resistors \\( R_1, R_2, ..., R_n \\) are in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^n \\frac{1}{R_i} $$ \ud83e\uddea Option 2: Python Implementation with networkx import networkx as nx def equivalent_resistance(graph, source, target): G = graph.copy() while True: changed = False # Series reduction for node in list(G.nodes): if node in [source, target] or G.degree[node] != 2: continue neighbors = list(G.neighbors(node)) if len(neighbors) != 2: continue u, v = neighbors if G.number_of_edges(u, node) > 1 or G.number_of_edges(v, node) > 1: continue R1 = G[u][node]['resistance'] R2 = G[v][node]['resistance'] R_eq = R1 + R2 G.add_edge(u, v, resistance=R_eq) G.remove_node(node) changed = True break if changed: continue # Parallel reduction for u, v in list(G.edges()): parallel_edges = [(u, v)] if G.number_of_edges(u, v) > 1: resistances = [G[u][v]['resistance']] for i in range(G.number_of_edges(u, v) - 1): resistances.append(G[u][v + f'_{i}']['resistance']) R_eq = 1 / sum(1 / R for R in resistances) G.remove_edges_from(parallel_edges) G.add_edge(u, v, resistance=R_eq) changed = True break if not changed: break return G[source][target]['resistance'] \ud83d\udd2c Examples Example 1: Series Nodes: A \u2014 B \u2014 C Resistors: A-B: 2 \u03a9 B-C: 3 \u03a9 Expected Result : $$ R_{\\text{eq}} = 2 + 3 = 5 \\, \\Omega $$ Example 2: Parallel Nodes: A, B Resistors: A-B: 4 \u03a9 A-B: 6 \u03a9 Expected Result : $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{4} + \\frac{1}{6} = \\frac{5}{12} \\Rightarrow R_{\\text{eq}} = \\frac{12}{5} = 2.4 \\, \\Omega $$ Example 3: Nested A\u2014B\u2014C with 3 edges from A to C (parallel to path A-B-C) A-B: 1 \u03a9 B-C: 1 \u03a9 A-C: 2 \u03a9 Series path A-B-C: \\( 1 + 1 = 2 \\, \\Omega \\) Parallel with direct A-C: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{2} + \\frac{1}{2} = 1 \\Rightarrow R_{\\text{eq}} = 1 \\, \\Omega $$ \ud83e\udde0 Analysis Time complexity : Worst-case: \\( O(n^2) \\) for checking all node pairs for parallel edges. More efficient with union-find or disjoint set optimizations. Improvements : Use DFS or BFS to identify reducible structures. Apply symbolic computation for variable resistors. \u2705 Conclusion Graph-based reduction provides a robust way to compute equivalent resistance for any circuit topology. This method can be used in simulation tools, CAD software, and optimization applications.","title":"\ud83d\udd0c Circuits Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits-problem-1","text":"","title":"\ud83d\udd0c Circuits Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating the equivalent resistance of a complex circuit is essential in circuit analysis. Traditional methods of reducing series and parallel resistors work for small circuits but become cumbersome with larger networks. Graph theory allows us to represent circuits as graphs: - Nodes : Electrical junctions - Edges : Resistors (with weights representing resistance) This method enables a systematic and automated reduction process, suitable for simulation and optimization.","title":"\ud83e\udde0 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-1-algorithm-description","text":"We aim to simplify the circuit iteratively using graph-theoretical principles.","title":"\ud83d\udee0\ufe0f Option 1: Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation","text":"Given a circuit graph \\( G = (V, E) \\) : \\( V \\) : set of nodes (junctions) \\( E \\) : set of edges (resistors), each with a weight \\( R_e \\)","title":"\ud83d\udcc8 Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"While the graph has more than two nodes: Identify series and parallel connections. Replace them with their equivalent resistance. Return the resistance between the source and destination nodes.","title":"\ud83d\udd01 Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"function simplify_circuit(graph, source, target): while graph has more than 2 nodes: for each node v in graph: if v has degree 2 and not in [source, target]: # Series reduction u, w = neighbors of v R1 = resistance(u, v) R2 = resistance(v, w) R_eq = R1 + R2 remove v and its edges add edge (u, w) with resistance R_eq for each pair of nodes (u, v): if multiple edges exist between u and v: # Parallel reduction resistances = [R1, R2, ..., Rn] R_eq = 1 / sum(1/R for R in resistances) remove all parallel edges add edge (u, v) with resistance R_eq return resistance between source and target","title":"\u2699\ufe0f Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#formulas","text":"Series : If resistors \\( R_1 \\) and \\( R_2 \\) are in series: $$ R_{\\text{eq}} = R_1 + R_2 $$ Parallel : If resistors \\( R_1, R_2, ..., R_n \\) are in parallel: $$ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^n \\frac{1}{R_i} $$","title":"\ud83e\uddee Formulas"},{"location":"1%20Physics/5%20Circuits/Problem_1/#option-2-python-implementation-with-networkx","text":"import networkx as nx def equivalent_resistance(graph, source, target): G = graph.copy() while True: changed = False # Series reduction for node in list(G.nodes): if node in [source, target] or G.degree[node] != 2: continue neighbors = list(G.neighbors(node)) if len(neighbors) != 2: continue u, v = neighbors if G.number_of_edges(u, node) > 1 or G.number_of_edges(v, node) > 1: continue R1 = G[u][node]['resistance'] R2 = G[v][node]['resistance'] R_eq = R1 + R2 G.add_edge(u, v, resistance=R_eq) G.remove_node(node) changed = True break if changed: continue # Parallel reduction for u, v in list(G.edges()): parallel_edges = [(u, v)] if G.number_of_edges(u, v) > 1: resistances = [G[u][v]['resistance']] for i in range(G.number_of_edges(u, v) - 1): resistances.append(G[u][v + f'_{i}']['resistance']) R_eq = 1 / sum(1 / R for R in resistances) G.remove_edges_from(parallel_edges) G.add_edge(u, v, resistance=R_eq) changed = True break if not changed: break return G[source][target]['resistance']","title":"\ud83e\uddea Option 2: Python Implementation with networkx"},{"location":"1%20Physics/5%20Circuits/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/5%20Circuits/Problem_1/#examples","text":"","title":"\ud83d\udd2c Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-series","text":"Nodes: A \u2014 B \u2014 C Resistors: A-B: 2 \u03a9 B-C: 3 \u03a9 Expected Result : $$ R_{\\text{eq}} = 2 + 3 = 5 \\, \\Omega $$","title":"Example 1: Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-parallel","text":"Nodes: A, B Resistors: A-B: 4 \u03a9 A-B: 6 \u03a9 Expected Result : $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{4} + \\frac{1}{6} = \\frac{5}{12} \\Rightarrow R_{\\text{eq}} = \\frac{12}{5} = 2.4 \\, \\Omega $$","title":"Example 2: Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested","text":"A\u2014B\u2014C with 3 edges from A to C (parallel to path A-B-C) A-B: 1 \u03a9 B-C: 1 \u03a9 A-C: 2 \u03a9 Series path A-B-C: \\( 1 + 1 = 2 \\, \\Omega \\) Parallel with direct A-C: $$ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{2} + \\frac{1}{2} = 1 \\Rightarrow R_{\\text{eq}} = 1 \\, \\Omega $$","title":"Example 3: Nested"},{"location":"1%20Physics/5%20Circuits/Problem_1/#analysis","text":"Time complexity : Worst-case: \\( O(n^2) \\) for checking all node pairs for parallel edges. More efficient with union-find or disjoint set optimizations. Improvements : Use DFS or BFS to identify reducible structures. Apply symbolic computation for variable resistors.","title":"\ud83e\udde0 Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"Graph-based reduction provides a robust way to compute equivalent resistance for any circuit topology. This method can be used in simulation tools, CAD software, and optimization applications.","title":"\u2705 Conclusion"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83d\udcca Exploring the Central Limit Theorem through Simulations \ud83c\udfaf Motivation The Central Limit Theorem (CLT) states that if we repeatedly draw random samples of size \\(n\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the distribution of the sample means \\(\\bar{X}\\) approaches a normal distribution \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) as \\(n \\to \\infty\\) , regardless of the original distribution of the population. This notebook simulates this principle using different population distributions. \ud83d\udee0\ufe0f Tools Used import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\") 1\ufe0f\u20e3 Population Distributions We explore 3 different distributions: Uniform : \\(\\mathcal{U}(0, 1)\\) Exponential : \\(\\text{Exp}(\\lambda=1)\\) Binomial : \\(\\text{Bin}(n=10, p=0.5)\\) # Set seed for reproducibility np.random.seed(42) # Generate large populations pop_size = 100_000 uniform_pop = np.random.uniform(0, 1, pop_size) exponential_pop = np.random.exponential(1, pop_size) binomial_pop = np.random.binomial(n=10, p=0.5, size=pop_size) 2\ufe0f\u20e3 Sampling and Visualization We draw samples of various sizes and compute sample means. This is repeated many times to visualize the sampling distribution. def sample_means(population, sample_size, n_samples=1000): return [np.mean(np.random.choice(population, sample_size)) for _ in range(n_samples)] We compare histograms of sample means for different sample sizes: sample_sizes = [5, 10, 30, 50] def plot_sampling_distribution(population, name): plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes): means = sample_means(population, size) plt.subplot(2, 2, i + 1) sns.histplot(means, bins=30, kde=True, color=\"skyblue\") plt.title(f\"{name} - Sample size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distributions from {name} Population\", fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() plot_sampling_distribution(uniform_pop, \"Uniform(0,1)\") plot_sampling_distribution(exponential_pop, \"Exponential(\u03bb=1)\") plot_sampling_distribution(binomial_pop, \"Binomial(n=10, p=0.5)\") 3\ufe0f\u20e3 Parameter Exploration \u2705 Observation: As the sample size increases , the distribution of sample means approaches a normal distribution regardless of the original shape. \ud83d\udccf Spread of Sampling Distribution: The standard deviation of the sample means (Standard Error) is: $$ \\text{SE} = \\frac{\\sigma}{\\sqrt{n}} $$ This explains why the sampling distributions become narrower as \\(n\\) increases. \ud83d\udcda 4\ufe0f\u20e3 Practical Applications of CLT Quality Control : Monitoring manufacturing processes by sampling batches. Surveys and Polling : Estimating population opinions via random samples. Finance : Modeling average returns or risk in portfolios. Medical Trials : Assessing treatment effectiveness from samples. \ud83d\udccc Summary The CLT ensures that the sampling distribution of the mean becomes normal with increasing sample size. Simulations with uniform, exponential, and binomial populations confirmed this visually. The rate of convergence depends on the original distribution and sample size . \ud83d\udcc1 References Rice, J. A. (2006). Mathematical Statistics and Data Analysis . Wackerly, D., Mendenhall, W., & Scheaffer, R. (2008). Mathematical Statistics with Applications .","title":"\ud83d\udcca Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"\ud83d\udcca Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) states that if we repeatedly draw random samples of size \\(n\\) from a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the distribution of the sample means \\(\\bar{X}\\) approaches a normal distribution \\(\\mathcal{N}(\\mu, \\sigma^2/n)\\) as \\(n \\to \\infty\\) , regardless of the original distribution of the population. This notebook simulates this principle using different population distributions.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#tools-used","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns sns.set(style=\"whitegrid\")","title":"\ud83d\udee0\ufe0f Tools Used"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-population-distributions","text":"We explore 3 different distributions: Uniform : \\(\\mathcal{U}(0, 1)\\) Exponential : \\(\\text{Exp}(\\lambda=1)\\) Binomial : \\(\\text{Bin}(n=10, p=0.5)\\) # Set seed for reproducibility np.random.seed(42) # Generate large populations pop_size = 100_000 uniform_pop = np.random.uniform(0, 1, pop_size) exponential_pop = np.random.exponential(1, pop_size) binomial_pop = np.random.binomial(n=10, p=0.5, size=pop_size)","title":"1\ufe0f\u20e3 Population Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"We draw samples of various sizes and compute sample means. This is repeated many times to visualize the sampling distribution. def sample_means(population, sample_size, n_samples=1000): return [np.mean(np.random.choice(population, sample_size)) for _ in range(n_samples)] We compare histograms of sample means for different sample sizes: sample_sizes = [5, 10, 30, 50] def plot_sampling_distribution(population, name): plt.figure(figsize=(16, 10)) for i, size in enumerate(sample_sizes): means = sample_means(population, size) plt.subplot(2, 2, i + 1) sns.histplot(means, bins=30, kde=True, color=\"skyblue\") plt.title(f\"{name} - Sample size {size}\") plt.xlabel(\"Sample Mean\") plt.ylabel(\"Frequency\") plt.suptitle(f\"Sampling Distributions from {name} Population\", fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() plot_sampling_distribution(uniform_pop, \"Uniform(0,1)\") plot_sampling_distribution(exponential_pop, \"Exponential(\u03bb=1)\") plot_sampling_distribution(binomial_pop, \"Binomial(n=10, p=0.5)\")","title":"2\ufe0f\u20e3 Sampling and Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-parameter-exploration","text":"","title":"3\ufe0f\u20e3 Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observation","text":"As the sample size increases , the distribution of sample means approaches a normal distribution regardless of the original shape.","title":"\u2705 Observation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#spread-of-sampling-distribution","text":"The standard deviation of the sample means (Standard Error) is: $$ \\text{SE} = \\frac{\\sigma}{\\sqrt{n}} $$ This explains why the sampling distributions become narrower as \\(n\\) increases.","title":"\ud83d\udccf Spread of Sampling Distribution:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#4-practical-applications-of-clt","text":"Quality Control : Monitoring manufacturing processes by sampling batches. Surveys and Polling : Estimating population opinions via random samples. Finance : Modeling average returns or risk in portfolios. Medical Trials : Assessing treatment effectiveness from samples.","title":"\ud83d\udcda 4\ufe0f\u20e3 Practical Applications of CLT"},{"location":"1%20Physics/6%20Statistics/Problem_1/#summary","text":"The CLT ensures that the sampling distribution of the mean becomes normal with increasing sample size. Simulations with uniform, exponential, and binomial populations confirmed this visually. The rate of convergence depends on the original distribution and sample size .","title":"\ud83d\udccc Summary"},{"location":"1%20Physics/6%20Statistics/Problem_1/#references","text":"Rice, J. A. (2006). Mathematical Statistics and Data Analysis . Wackerly, D., Mendenhall, W., & Scheaffer, R. (2008). Mathematical Statistics with Applications .","title":"\ud83d\udcc1 References"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \u03c0 Using Monte Carlo Methods This document explains two methods for estimating \u03c0 using Monte Carlo simulations: (1) Circle-based method, and (2) Buffon's Needle method. It includes theoretical foundations, Python code implementations, visualizations, and analysis. Part 1: Estimating \u03c0 Using a Circle 1. Theoretical Foundation The method relies on the geometric relationship between a circle inscribed in a square. For a unit circle (radius = 1), the area of the circle is $ \\pi r^2 = \\pi \\cdot 1^2 = \\pi $, and the area of the square that bounds it is $ 4 \\cdot 1^2 = 4 $. The ratio of the areas is therefore: \\[ \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] By generating random points uniformly within the square, the proportion of points that fall inside the circle approximates this ratio. Thus, we can estimate \u03c0 as: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Number of Points Inside Circle}}{\\text{Total Number of Points}} \\] Derivation for a Unit Circle: A point \\((x, y)\\) lies inside the unit circle if $ x^2 + y^2 \\leq 1 $. The square has vertices at \\((-1, -1)\\) , \\((-1, 1)\\) , \\((1, -1)\\) , and \\((1, 1)\\) . 2. Simulation Below is the Python implementation for the circle-based Monte Carlo simulation. ```python import numpy as np import matplotlib.pyplot as plt def estimate_pi(num_points): # Generate random points in the square [-1, 1] x [-1, 1] points = np.random.uniform(-1, 1, (num_points, 2)) # Determine which points fall inside the unit circle distances = np.linalg.norm(points, axis=1) inside_circle = distances <= 1 # Estimate pi pi_estimate = 4 * np.mean(inside_circle) # Visualization plt.figure(figsize=(6, 6)) plt.scatter(points[inside_circle, 0], points[inside_circle, 1], color='blue', s=1, label='Inside Circle') plt.scatter(points[~inside_circle, 0], points[~inside_circle, 1], color='red', s=1, label='Outside Circle') plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) plt.gca().set_aspect('equal', adjustable='box') plt.title(f'Estimation of \u03c0: {pi_estimate:.4f}') plt.legend() plt.show() return pi_estimate Run the simulation with 10,000 points estimate_pi(10000)","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-using-monte-carlo-methods","text":"This document explains two methods for estimating \u03c0 using Monte Carlo simulations: (1) Circle-based method, and (2) Buffon's Needle method. It includes theoretical foundations, Python code implementations, visualizations, and analysis.","title":"Estimating \u03c0 Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"The method relies on the geometric relationship between a circle inscribed in a square. For a unit circle (radius = 1), the area of the circle is $ \\pi r^2 = \\pi \\cdot 1^2 = \\pi $, and the area of the square that bounds it is $ 4 \\cdot 1^2 = 4 $. The ratio of the areas is therefore: \\[ \\frac{\\text{Area of Circle}}{\\text{Area of Square}} = \\frac{\\pi}{4} \\] By generating random points uniformly within the square, the proportion of points that fall inside the circle approximates this ratio. Thus, we can estimate \u03c0 as: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Number of Points Inside Circle}}{\\text{Total Number of Points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#derivation-for-a-unit-circle","text":"A point \\((x, y)\\) lies inside the unit circle if $ x^2 + y^2 \\leq 1 $. The square has vertices at \\((-1, -1)\\) , \\((-1, 1)\\) , \\((1, -1)\\) , and \\((1, 1)\\) .","title":"Derivation for a Unit Circle:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Below is the Python implementation for the circle-based Monte Carlo simulation. ```python import numpy as np import matplotlib.pyplot as plt def estimate_pi(num_points): # Generate random points in the square [-1, 1] x [-1, 1] points = np.random.uniform(-1, 1, (num_points, 2)) # Determine which points fall inside the unit circle distances = np.linalg.norm(points, axis=1) inside_circle = distances <= 1 # Estimate pi pi_estimate = 4 * np.mean(inside_circle) # Visualization plt.figure(figsize=(6, 6)) plt.scatter(points[inside_circle, 0], points[inside_circle, 1], color='blue', s=1, label='Inside Circle') plt.scatter(points[~inside_circle, 0], points[~inside_circle, 1], color='red', s=1, label='Outside Circle') plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) plt.gca().set_aspect('equal', adjustable='box') plt.title(f'Estimation of \u03c0: {pi_estimate:.4f}') plt.legend() plt.show() return pi_estimate","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#run-the-simulation-with-10000-points","text":"estimate_pi(10000)","title":"Run the simulation with 10,000 points"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration Using a Pendulum Motivation: The acceleration due to gravity ($ g $) is a fundamental constant that influences a wide range of physical phenomena. Measuring $ g $ accurately is crucial for understanding gravitational fields, conducting experiments in various fields, and analyzing local gravitational variations. This problem involves measuring $ g $ using the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. The exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics. Task: Measure the acceleration due to gravity ($ g $) using a pendulum and analyze the uncertainties in the measurements. Materials: A string (1 or 2 meters long) A small, dense object (e.g., a metal ball) Stopwatch Ruler or measuring tape Support stand (to suspend the pendulum) Procedure: Setup the Pendulum: Attach the string to the support stand and suspend the small object to create a pendulum. Ensure the pendulum can swing freely without obstruction. Adjust the Length: Measure and record the length $ L $ of the pendulum (from the pivot point to the center of mass of the object). Measure the Period: Displace the pendulum slightly (less than $ 10^\\circ $) from its equilibrium position and release it. Use the stopwatch to measure the time for 10 complete oscillations. Repeat this measurement at least three times to ensure accuracy. Calculate the Period: Compute the average time for 10 oscillations and divide by 10 to find the period $ T $. Repeat for Different Lengths: Change the length of the pendulum and repeat the measurements for at least three different lengths. Theoretical Foundation: The period $ T $ of a simple pendulum for small angular displacements is given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Rearranging for $ g $, we get: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Where: - $ L $ is the length of the pendulum, - $ T $ is the period of oscillation, - $ g $ is the gravitational acceleration. Python Code Implementation: Below is the Python code to calculate $ g $ based on measured data and visualize the results. ```python import numpy as np import matplotlib.pyplot as plt Function to calculate g from pendulum data def calculate_gravity(lengths, periods): \"\"\" Calculate gravitational acceleration g using the formula: g = 4 * pi^2 * L / T^2 \"\"\" g_values = [] for L, T in zip(lengths, periods): g = (4 * np.pi 2 * L) / T 2 g_values.append(g) return g_values Example data: lengths (in meters) and periods (in seconds) lengths = [1.0, 1.5, 2.0] # Replace with your measured lengths periods = [2.01, 2.46, 2.84] # Replace with your measured periods Calculate g for each length g_values = calculate_gravity(lengths, periods) Print results print(\"Gravitational Acceleration (g) Values:\") for i, g in enumerate(g_values): print(f\"Length {lengths[i]} m: g = {g:.3f} m/s^2\") Average g value average_g = np.mean(g_values) print(f\"\\nAverage Gravitational Acceleration (g): {average_g:.3f} m/s^2\") Plotting plt.figure(figsize=(8, 6)) plt.plot(lengths, g_values, marker='o', linestyle='-', color='blue') plt.axhline(y=9.81, color='red', linestyle='--', label='Standard g = 9.81 m/s\u00b2') plt.title('Measured Gravitational Acceleration vs. Pendulum Length') plt.xlabel('Pendulum Length (m)') plt.ylabel('Gravitational Acceleration (m/s\u00b2)') plt.legend() plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-using-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration Using a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity ($ g $) is a fundamental constant that influences a wide range of physical phenomena. Measuring $ g $ accurately is crucial for understanding gravitational fields, conducting experiments in various fields, and analyzing local gravitational variations. This problem involves measuring $ g $ using the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. The exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics.","title":"Motivation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the acceleration due to gravity ($ g $) using a pendulum and analyze the uncertainties in the measurements.","title":"Task:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"A string (1 or 2 meters long) A small, dense object (e.g., a metal ball) Stopwatch Ruler or measuring tape Support stand (to suspend the pendulum)","title":"Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"Setup the Pendulum: Attach the string to the support stand and suspend the small object to create a pendulum. Ensure the pendulum can swing freely without obstruction. Adjust the Length: Measure and record the length $ L $ of the pendulum (from the pivot point to the center of mass of the object). Measure the Period: Displace the pendulum slightly (less than $ 10^\\circ $) from its equilibrium position and release it. Use the stopwatch to measure the time for 10 complete oscillations. Repeat this measurement at least three times to ensure accuracy. Calculate the Period: Compute the average time for 10 oscillations and divide by 10 to find the period $ T $. Repeat for Different Lengths: Change the length of the pendulum and repeat the measurements for at least three different lengths.","title":"Procedure:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#theoretical-foundation","text":"The period $ T $ of a simple pendulum for small angular displacements is given by: \\[ T = 2\\pi \\sqrt{\\frac{L}{g}} \\] Rearranging for $ g $, we get: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Where: - $ L $ is the length of the pendulum, - $ T $ is the period of oscillation, - $ g $ is the gravitational acceleration.","title":"Theoretical Foundation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code-implementation","text":"Below is the Python code to calculate $ g $ based on measured data and visualize the results. ```python import numpy as np import matplotlib.pyplot as plt","title":"Python Code Implementation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#function-to-calculate-g-from-pendulum-data","text":"def calculate_gravity(lengths, periods): \"\"\" Calculate gravitational acceleration g using the formula: g = 4 * pi^2 * L / T^2 \"\"\" g_values = [] for L, T in zip(lengths, periods): g = (4 * np.pi 2 * L) / T 2 g_values.append(g) return g_values","title":"Function to calculate g from pendulum data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-data-lengths-in-meters-and-periods-in-seconds","text":"lengths = [1.0, 1.5, 2.0] # Replace with your measured lengths periods = [2.01, 2.46, 2.84] # Replace with your measured periods","title":"Example data: lengths (in meters) and periods (in seconds)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculate-g-for-each-length","text":"g_values = calculate_gravity(lengths, periods)","title":"Calculate g for each length"},{"location":"1%20Physics/7%20Measurements/Problem_1/#print-results","text":"print(\"Gravitational Acceleration (g) Values:\") for i, g in enumerate(g_values): print(f\"Length {lengths[i]} m: g = {g:.3f} m/s^2\")","title":"Print results"},{"location":"1%20Physics/7%20Measurements/Problem_1/#average-g-value","text":"average_g = np.mean(g_values) print(f\"\\nAverage Gravitational Acceleration (g): {average_g:.3f} m/s^2\")","title":"Average g value"},{"location":"1%20Physics/7%20Measurements/Problem_1/#plotting","text":"plt.figure(figsize=(8, 6)) plt.plot(lengths, g_values, marker='o', linestyle='-', color='blue') plt.axhline(y=9.81, color='red', linestyle='--', label='Standard g = 9.81 m/s\u00b2') plt.title('Measured Gravitational Acceleration vs. Pendulum Length') plt.xlabel('Pendulum Length (m)') plt.ylabel('Gravitational Acceleration (m/s\u00b2)') plt.legend() plt.grid(True) plt.show()","title":"Plotting"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}