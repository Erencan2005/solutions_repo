{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Deriving the Governing Equations The motion of a projectile can be described by applying Newton's second law. For a projectile launched from an initial position with velocity \\(v_0\\) at an angle \\(\\theta\\) with respect to the horizontal, we have: In the horizontal direction (x-axis): \\( \\(\\frac{d^2x}{dt^2} = 0\\) \\) In the vertical direction (y-axis): \\( \\(\\frac{d^2y}{dt^2} = -g\\) \\) Where \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2 on Earth). Integrating these equations with respect to time with initial conditions: - \\(x(0) = 0\\) - \\(y(0) = h\\) (initial height) - \\(v_x(0) = v_0\\cos(\\theta)\\) - \\(v_y(0) = v_0\\sin(\\theta)\\) We obtain: \\[x(t) = (v_0\\cos\\theta)t$$ $$y(t) = h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2\\] These parametric equations describe the position of the projectile at any time \\(t\\) . Family of Solutions The family of solutions is defined by varying the parameters: - Initial velocity ( \\(v_0\\) ) - Launch angle ( \\(\\theta\\) ) - Initial height ( \\(h\\) ) - Gravitational acceleration ( \\(g\\) ) Each combination of these parameters produces a unique trajectory. 2. Analysis of the Range Range Equation The range \\(R\\) is the horizontal distance traveled when the projectile returns to its initial height. To find this, we need to determine when \\(y(t) = h\\) : \\[h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = h\\] Simplifying: \\( \\((v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = 0\\) \\) This equation has two solutions: \\(t = 0\\) and \\(t = \\frac{2v_0\\sin\\theta}{g}\\) The second solution gives us the time of flight. The range is then: \\[R = (v_0\\cos\\theta) \\cdot \\frac{2v_0\\sin\\theta}{g} = \\frac{v_0^2\\sin(2\\theta)}{g}\\] This demonstrates that the range is proportional to: - The square of the initial velocity - The sine of twice the angle of projection - Inversely proportional to the gravitational acceleration Optimal Angle for Maximum Range To find the angle that maximizes the range, we differentiate with respect to \\(\\theta\\) and set it equal to zero: \\[\\frac{dR}{d\\theta} = \\frac{v_0^2\\cos(2\\theta)}{g} = 0\\] This gives us \\(\\cos(2\\theta) = 0\\) , thus \\(2\\theta = \\frac{\\pi}{2}\\) or \\(\\theta = \\frac{\\pi}{4} = 45\u00b0\\) Therefore, in the absence of air resistance and with a level landing surface, the maximum range is achieved at a 45\u00b0 angle. Effect of Initial Height If the projectile is launched from a height \\(h\\) above the landing surface, the range equation becomes more complex: \\[R = v_0\\cos\\theta \\cdot t_{landing}\\] Where \\(t_{landing}\\) is the time when the projectile reaches the ground level ( \\(y = 0\\) ): \\[h + (v_0\\sin\\theta)t_{landing} - \\frac{1}{2}gt_{landing}^2 = 0\\] Solving this quadratic equation: \\[t_{landing} = \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] This means that the range now depends on the initial height as well: \\[R = v_0\\cos\\theta \\cdot \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] 3. Practical Applications Real-world Considerations In practice, projectile motion is influenced by: - Air resistance (drag) - Wind - Varying gravitational field - Rotating reference frames (Coriolis effect) - Non-uniform terrain Incorporating Air Resistance A simple model for air resistance is to include a drag force proportional to velocity: \\[F_d = -bv\\] This leads to a modified set of differential equations: \\[\\frac{d^2x}{dt^2} = -\\frac{b}{m}v_x$$ $$\\frac{d^2y}{dt^2} = -g - \\frac{b}{m}v_y\\] Where \\(b\\) is the drag coefficient and \\(m\\) is the mass of the projectile. These equations typically require numerical methods to solve. 4. pyhton Implementation","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#deriving-the-governing-equations","text":"The motion of a projectile can be described by applying Newton's second law. For a projectile launched from an initial position with velocity \\(v_0\\) at an angle \\(\\theta\\) with respect to the horizontal, we have: In the horizontal direction (x-axis): \\( \\(\\frac{d^2x}{dt^2} = 0\\) \\) In the vertical direction (y-axis): \\( \\(\\frac{d^2y}{dt^2} = -g\\) \\) Where \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2 on Earth). Integrating these equations with respect to time with initial conditions: - \\(x(0) = 0\\) - \\(y(0) = h\\) (initial height) - \\(v_x(0) = v_0\\cos(\\theta)\\) - \\(v_y(0) = v_0\\sin(\\theta)\\) We obtain: \\[x(t) = (v_0\\cos\\theta)t$$ $$y(t) = h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2\\] These parametric equations describe the position of the projectile at any time \\(t\\) .","title":"Deriving the Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"The family of solutions is defined by varying the parameters: - Initial velocity ( \\(v_0\\) ) - Launch angle ( \\(\\theta\\) ) - Initial height ( \\(h\\) ) - Gravitational acceleration ( \\(g\\) ) Each combination of these parameters produces a unique trajectory.","title":"Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"The range \\(R\\) is the horizontal distance traveled when the projectile returns to its initial height. To find this, we need to determine when \\(y(t) = h\\) : \\[h + (v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = h\\] Simplifying: \\( \\((v_0\\sin\\theta)t - \\frac{1}{2}gt^2 = 0\\) \\) This equation has two solutions: \\(t = 0\\) and \\(t = \\frac{2v_0\\sin\\theta}{g}\\) The second solution gives us the time of flight. The range is then: \\[R = (v_0\\cos\\theta) \\cdot \\frac{2v_0\\sin\\theta}{g} = \\frac{v_0^2\\sin(2\\theta)}{g}\\] This demonstrates that the range is proportional to: - The square of the initial velocity - The sine of twice the angle of projection - Inversely proportional to the gravitational acceleration","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#optimal-angle-for-maximum-range","text":"To find the angle that maximizes the range, we differentiate with respect to \\(\\theta\\) and set it equal to zero: \\[\\frac{dR}{d\\theta} = \\frac{v_0^2\\cos(2\\theta)}{g} = 0\\] This gives us \\(\\cos(2\\theta) = 0\\) , thus \\(2\\theta = \\frac{\\pi}{2}\\) or \\(\\theta = \\frac{\\pi}{4} = 45\u00b0\\) Therefore, in the absence of air resistance and with a level landing surface, the maximum range is achieved at a 45\u00b0 angle.","title":"Optimal Angle for Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-height","text":"If the projectile is launched from a height \\(h\\) above the landing surface, the range equation becomes more complex: \\[R = v_0\\cos\\theta \\cdot t_{landing}\\] Where \\(t_{landing}\\) is the time when the projectile reaches the ground level ( \\(y = 0\\) ): \\[h + (v_0\\sin\\theta)t_{landing} - \\frac{1}{2}gt_{landing}^2 = 0\\] Solving this quadratic equation: \\[t_{landing} = \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\] This means that the range now depends on the initial height as well: \\[R = v_0\\cos\\theta \\cdot \\frac{v_0\\sin\\theta + \\sqrt{(v_0\\sin\\theta)^2 + 2gh}}{g}\\]","title":"Effect of Initial Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#real-world-considerations","text":"In practice, projectile motion is influenced by: - Air resistance (drag) - Wind - Varying gravitational field - Rotating reference frames (Coriolis effect) - Non-uniform terrain","title":"Real-world Considerations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#incorporating-air-resistance","text":"A simple model for air resistance is to include a drag force proportional to velocity: \\[F_d = -bv\\] This leads to a modified set of differential equations: \\[\\frac{d^2x}{dt^2} = -\\frac{b}{m}v_x$$ $$\\frac{d^2y}{dt^2} = -g - \\frac{b}{m}v_y\\] Where \\(b\\) is the drag coefficient and \\(m\\) is the mass of the projectile. These equations typically require numerical methods to solve.","title":"Incorporating Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-pyhton-implementation","text":"","title":"4. pyhton Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance. Task 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency. Approximate Solutions for Small-Angle Oscillations For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations. Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed. 2. Analysis of Dynamics Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams. 3. Practical Applications Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits. 4. Implementation Computational Model Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() Visualization Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior. Deliverables Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics. Hints and Resources Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a captivating example of a physical system exhibiting intricate behavior due to the interplay of damping, restoring forces, and external periodic forces. By introducing damping and external forcing, the system transitions from simple harmonic motion to a rich spectrum of dynamics, including resonance, chaos, and quasiperiodic behavior. These phenomena provide insights into real-world systems, such as driven oscillators, climate models, and mechanical structures under periodic stress. Adding forcing introduces new parameters, such as the amplitude and frequency of the external force, which significantly affect the pendulum's behavior. Systematic variations in these parameters reveal synchronized oscillations, chaotic motion, and resonance phenomena. These behaviors highlight fundamental physics principles and provide engineering insights into energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin \\theta = F_0 \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency, - \\(F_0\\) is the amplitude of the external force, - \\(\\omega\\) is the driving frequency.","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solutions-for-small-angle-oscillations","text":"For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = F_0 \\cos(\\omega t) \\] Solving this using standard techniques yields solutions representing driven damped harmonic oscillations.","title":"Approximate Solutions for Small-Angle Oscillations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the system\u2019s natural frequency \\(\\omega_0\\) , leading to energy amplification. The impact of damping on resonance behavior and its practical implications in engineering are discussed.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Influence of the damping coefficient, driving amplitude, and frequency on motion. Transition from periodic to chaotic motion. Physical interpretations of regular and chaotic motion, explored via phase portraits and bifurcation diagrams.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting : Mechanical resonance in energy collection devices. Suspension Bridges : Understanding resonance-induced structural failures. Oscillating Circuits : Analogies to driven RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#computational-model","text":"Using Python, we numerically solve the forced damped pendulum equation using the Runge-Kutta method and visualize the results. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the forced damped pendulum equation def forced_damped_pendulum(t, y, gamma, omega0, F0, omega): theta, omega_t = y dydt = [ omega_t, -gamma * omega_t - omega0**2 * np.sin(theta) + F0 * np.cos(omega * t) ] return dydt # Parameters gamma = 0.2 # Damping coefficient omega0 = 1.0 # Natural frequency F0 = 0.5 # Driving force amplitude omega = 0.8 # Driving frequency time_span = (0, 50) # Simulation time initial_conditions = [0.1, 0] # Initial theta and angular velocity time_eval = np.linspace(*time_span, 1000) # Solve the differential equation solution = solve_ivp( forced_damped_pendulum, time_span, initial_conditions, t_eval=time_eval, args=(gamma, omega0, F0, omega) ) # Plot the results plt.figure(figsize=(10, 5)) plt.plot(solution.t, solution.y[0], label=\"Theta (rad)\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Computational Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#visualization","text":"Time evolution of \\(\\theta(t)\\) for different parameters. Phase diagrams illustrating different motion regimes. Poincar\u00e9 sections and bifurcation diagrams to explore chaotic behavior.","title":"Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"Markdown document with explanations and Python implementations. Graphical representations of motion under varying conditions. Discussion on model limitations and potential extensions, such as nonlinear damping and non-periodic driving forces. Phase portraits and bifurcation diagrams for understanding transitions to complex dynamics.","title":"Deliverables"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#hints-and-resources","text":"Use small-angle approximations where valid. Apply numerical techniques (Runge-Kutta) for beyond-small-angle exploration. Relate the pendulum dynamics to driven RLC circuits and biomechanics. Utilize Python for simulations and visualizations. This study bridges theoretical analysis and computational exploration, fostering a deeper understanding of forced and damped oscillatory phenomena in physics and engineering.","title":"Hints and Resources"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems. Task Derive the Relationship : Derive the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. Astronomical Implications : Discuss the implications of this relationship for astronomy, including its role in calculating planetary masses and distances. Real-World Examples : Analyze real-world examples, such as the Moon's orbit around Earth or the orbits of planets in the Solar System. Computational Model : Implement a computational model to simulate circular orbits and verify the relationship. Derivation of Kepler's Third Law For a small body orbiting a much larger body in a circular orbit, Newton's law of gravitation and centripetal force provide: [ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} ] where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius, - \\( v \\) is the orbital velocity. Since the orbital velocity is given by: [ v = \\frac{2 \\pi r}{T} ] substituting this into the force equation: [ \\frac{G M}{r^2} = \\frac{4 \\pi^2 r}{T^2} ] Rearranging to express \\( T^2 \\) in terms of \\( r^3 \\) : [ T^2 = \\frac{4 \\pi^2}{G M} r^3 ] This confirms that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\) , which is Kepler\u2019s Third Law. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt def orbital_period(radius, mass_central): \"\"\" Calculate the orbital period using Kepler's Third Law. \"\"\" G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return 2 * np.pi * np.sqrt(radius**3 / (G * mass_central)) # Define constants mass_earth = 5.972e24 # kg mass_sun = 1.989e30 # kg radii = np.linspace(1e7, 1.5e11, 100) # Radius range (m) periods = [orbital_period(r, mass_sun) for r in radii] # Plot T^2 vs R^3 plt.figure(figsize=(8, 6)) plt.plot(radii**3, np.array(periods)**2, label='T^2 vs R^3') plt.xlabel(\"Orbital Radius^3 (m^3)\") plt.ylabel(\"Orbital Period^2 (s^2)\") plt.title(\"Kepler's Third Law: T^2 vs R^3\") plt.legend() plt.grid() plt.show() # Simulating a simple circular orbit def simulate_orbit(radius, time_steps, mass_central): \"\"\" Simulate a circular orbit around a central mass. \"\"\" omega = np.sqrt(6.67430e-11 * mass_central / radius**3) # Angular velocity times = np.linspace(0, 2 * np.pi / omega, time_steps) x = radius * np.cos(omega * times) y = radius * np.sin(omega * times) plt.figure(figsize=(6, 6)) plt.plot(x, y, label='Orbit Path') plt.scatter(0, 0, color='red', label='Central Body') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbit\") plt.legend() plt.grid() plt.axis('equal') plt.show() simulate_orbit(1.5e10, 1000, mass_sun) Discussion Astronomical Applications : Kepler's Third Law is used to determine planetary distances and masses. It aids in calculating the orbits of exoplanets using observed transit periods. Extensions to Elliptical Orbits : The law generalizes to elliptical orbits with the semi-major axis \\( a \\) replacing \\( r \\) . This principle is foundational for understanding celestial mechanics. This simulation and derivation provide a deeper understanding of Kepler\u2019s Third Law and its significance in astrophysics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law, is a cornerstone of celestial mechanics. This simple yet profound relationship allows for the determination of planetary motions and has implications for understanding gravitational interactions on both local and cosmic scales. By analyzing this relationship, one can connect fundamental principles of gravity with real-world phenomena such as satellite orbits and planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#task","text":"Derive the Relationship : Derive the relationship between the square of the orbital period and the cube of the orbital radius for circular orbits. Astronomical Implications : Discuss the implications of this relationship for astronomy, including its role in calculating planetary masses and distances. Real-World Examples : Analyze real-world examples, such as the Moon's orbit around Earth or the orbits of planets in the Solar System. Computational Model : Implement a computational model to simulate circular orbits and verify the relationship.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a small body orbiting a much larger body in a circular orbit, Newton's law of gravitation and centripetal force provide: [ F = \\frac{G M m}{r^2} = m \\frac{v^2}{r} ] where: - \\( G \\) is the gravitational constant, - \\( M \\) is the mass of the central body, - \\( m \\) is the mass of the orbiting body, - \\( r \\) is the orbital radius, - \\( v \\) is the orbital velocity. Since the orbital velocity is given by: [ v = \\frac{2 \\pi r}{T} ] substituting this into the force equation: [ \\frac{G M}{r^2} = \\frac{4 \\pi^2 r}{T^2} ] Rearranging to express \\( T^2 \\) in terms of \\( r^3 \\) : [ T^2 = \\frac{4 \\pi^2}{G M} r^3 ] This confirms that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\) , which is Kepler\u2019s Third Law.","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt def orbital_period(radius, mass_central): \"\"\" Calculate the orbital period using Kepler's Third Law. \"\"\" G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return 2 * np.pi * np.sqrt(radius**3 / (G * mass_central)) # Define constants mass_earth = 5.972e24 # kg mass_sun = 1.989e30 # kg radii = np.linspace(1e7, 1.5e11, 100) # Radius range (m) periods = [orbital_period(r, mass_sun) for r in radii] # Plot T^2 vs R^3 plt.figure(figsize=(8, 6)) plt.plot(radii**3, np.array(periods)**2, label='T^2 vs R^3') plt.xlabel(\"Orbital Radius^3 (m^3)\") plt.ylabel(\"Orbital Period^2 (s^2)\") plt.title(\"Kepler's Third Law: T^2 vs R^3\") plt.legend() plt.grid() plt.show() # Simulating a simple circular orbit def simulate_orbit(radius, time_steps, mass_central): \"\"\" Simulate a circular orbit around a central mass. \"\"\" omega = np.sqrt(6.67430e-11 * mass_central / radius**3) # Angular velocity times = np.linspace(0, 2 * np.pi / omega, time_steps) x = radius * np.cos(omega * times) y = radius * np.sin(omega * times) plt.figure(figsize=(6, 6)) plt.plot(x, y, label='Orbit Path') plt.scatter(0, 0, color='red', label='Central Body') plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Simulated Circular Orbit\") plt.legend() plt.grid() plt.axis('equal') plt.show() simulate_orbit(1.5e10, 1000, mass_sun)","title":"Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion","text":"Astronomical Applications : Kepler's Third Law is used to determine planetary distances and masses. It aids in calculating the orbits of exoplanets using observed transit periods. Extensions to Elliptical Orbits : The law generalizes to elliptical orbits with the semi-major axis \\( a \\) replacing \\( r \\) . This principle is foundational for understanding celestial mechanics. This simulation and derivation provide a deeper understanding of Kepler\u2019s Third Law and its significance in astrophysics.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation: The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Task: Define the first, second, and third cosmic velocities, explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration, including launching satellites, missions to other planets, and potential interstellar travel. Deliverables: A Markdown document with a Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of escape velocities and cosmic velocities for various celestial bodies. Mathematical Formulation The first cosmic velocity ( \\(v_1\\) ), or orbital velocity, is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ The second cosmic velocity ( \\(v_2\\) ), or escape velocity, is: $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2GM}{R}} $$ The third cosmic velocity ( \\(v_3\\) ), the velocity needed to leave the star system, is given by: $$ v_3 = \\sqrt{2 \\frac{GM_{\\text{sun}}}{d}} $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ). - \\(M\\) is the mass of the celestial body. - \\(R\\) is the radius of the celestial body. - \\(M_{\\text{sun}}\\) is the mass of the Sun. - \\(d\\) is the distance from the Sun. Python Code for Simulation import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(mass, radius): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): return np.sqrt(2) * first_cosmic_velocity(mass, radius) def third_cosmic_velocity(mass_sun, distance): return np.sqrt(2 * 6.67430e-11 * mass_sun / distance) # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7), } # Compute velocities velocities = {} for body, (mass, radius) in bodies.items(): v1 = first_cosmic_velocity(mass, radius) v2 = second_cosmic_velocity(mass, radius) velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots() labels, v1_vals, v2_vals = zip(*[(k, v[0], v[1]) for k, v in velocities.items()]) x = np.arange(len(labels)) ax.bar(x - 0.2, v1_vals, 0.4, label=\"First Cosmic Velocity (m/s)\") ax.bar(x + 0.2, v2_vals, 0.4, label=\"Second Cosmic Velocity (m/s)\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Cosmic Velocities of Different Celestial Bodies\") ax.legend() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#task","text":"Define the first, second, and third cosmic velocities, explaining their physical meaning. Analyze the mathematical derivations and parameters affecting these velocities. Calculate and visualize these velocities for different celestial bodies like Earth, Mars, and Jupiter. Discuss their importance in space exploration, including launching satellites, missions to other planets, and potential interstellar travel.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"A Markdown document with a Python script or notebook implementing the simulations. A detailed explanation of the subjects. Graphical representations of escape velocities and cosmic velocities for various celestial bodies.","title":"Deliverables:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-formulation","text":"The first cosmic velocity ( \\(v_1\\) ), or orbital velocity, is given by: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ The second cosmic velocity ( \\(v_2\\) ), or escape velocity, is: $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2GM}{R}} $$ The third cosmic velocity ( \\(v_3\\) ), the velocity needed to leave the star system, is given by: $$ v_3 = \\sqrt{2 \\frac{GM_{\\text{sun}}}{d}} $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ). - \\(M\\) is the mass of the celestial body. - \\(R\\) is the radius of the celestial body. - \\(M_{\\text{sun}}\\) is the mass of the Sun. - \\(d\\) is the distance from the Sun.","title":"Mathematical Formulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(mass, radius): G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): return np.sqrt(2) * first_cosmic_velocity(mass, radius) def third_cosmic_velocity(mass_sun, distance): return np.sqrt(2 * 6.67430e-11 * mass_sun / distance) # Celestial bodies (mass in kg, radius in meters) bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.3895e6), \"Jupiter\": (1.898e27, 6.9911e7), } # Compute velocities velocities = {} for body, (mass, radius) in bodies.items(): v1 = first_cosmic_velocity(mass, radius) v2 = second_cosmic_velocity(mass, radius) velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots() labels, v1_vals, v2_vals = zip(*[(k, v[0], v[1]) for k, v in velocities.items()]) x = np.arange(len(labels)) ax.bar(x - 0.2, v1_vals, 0.4, label=\"First Cosmic Velocity (m/s)\") ax.bar(x + 0.2, v2_vals, 0.4, label=\"Second Cosmic Velocity (m/s)\") ax.set_xticks(x) ax.set_xticklabels(labels) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"Cosmic Velocities of Different Celestial Bodies\") ax.legend() plt.show()","title":"Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation: When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task: Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Mathematical Formulation The motion of the payload is governed by Newton's law of universal gravitation: $$ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} $$ This results in the following equations of motion: $$ \\frac{d^2 x}{dt^2} = -\\frac{GM}{r^3} x $$ $$ \\frac{d^2 y}{dt^2} = -\\frac{GM}{r^3} y $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ) - \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\ kg\\) ) - \\(r = \\sqrt{x^2 + y^2}\\) is the radial distance from Earth's center - \\((x, y)\\) are the coordinates of the payload Python Code for Simulation ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay] Initial conditions (altitude = 300 km, velocity = 7800 m/s tangentially) altitude = 300e3 x0, y0 = R_earth + altitude, 0 vx0, vy0 = 0, 7800 # m/s initial_state = [x0, y0, vx0, vy0] Time span for simulation time_span = (0, 6000) # 6000 seconds time_eval = np.linspace(*time_span, 1000) sol = solve_ivp(equations, time_span, initial_state, t_eval=time_eval, method='RK45') Extract results x_vals, y_vals = sol.y[0], sol.y[1] Plot the trajectory plt.figure(figsize=(8, 8)) plt.plot(x_vals, y_vals, label=\"Payload Trajectory\") plt.plot(0, 0, 'ro', label=\"Earth\") Draw Earth earth_circle = plt.Circle((0, 0), R_earth, color='b', alpha=0.3, label=\"Earth Surface\") plt.gca().add_patch(earth_circle) plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion, reentry, or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mathematical-formulation","text":"The motion of the payload is governed by Newton's law of universal gravitation: $$ \\mathbf{F} = -\\frac{GMm}{r^2} \\hat{r} $$ This results in the following equations of motion: $$ \\frac{d^2 x}{dt^2} = -\\frac{GM}{r^3} x $$ $$ \\frac{d^2 y}{dt^2} = -\\frac{GM}{r^3} y $$ Where: - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\ m^3 kg^{-1} s^{-2}\\) ) - \\(M\\) is Earth's mass ( \\(5.972 \\times 10^{24} \\ kg\\) ) - \\(r = \\sqrt{x^2 + y^2}\\) is the radial distance from Earth's center - \\((x, y)\\) are the coordinates of the payload","title":"Mathematical Formulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-for-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"def equations(t, state): x, y, vx, vy = state r = np.sqrt(x 2 + y 2) ax = -G * M * x / r 3 ay = -G * M * y / r 3 return [vx, vy, ax, ay]","title":"Equations of motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions-altitude-300-km-velocity-7800-ms-tangentially","text":"altitude = 300e3 x0, y0 = R_earth + altitude, 0 vx0, vy0 = 0, 7800 # m/s initial_state = [x0, y0, vx0, vy0]","title":"Initial conditions (altitude = 300 km, velocity = 7800 m/s tangentially)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-span-for-simulation","text":"time_span = (0, 6000) # 6000 seconds time_eval = np.linspace(*time_span, 1000) sol = solve_ivp(equations, time_span, initial_state, t_eval=time_eval, method='RK45')","title":"Time span for simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#extract-results","text":"x_vals, y_vals = sol.y[0], sol.y[1]","title":"Extract results"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-the-trajectory","text":"plt.figure(figsize=(8, 8)) plt.plot(x_vals, y_vals, label=\"Payload Trajectory\") plt.plot(0, 0, 'ro', label=\"Earth\")","title":"Plot the trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#draw-earth","text":"earth_circle = plt.Circle((0, 0), R_earth, color='b', alpha=0.3, label=\"Earth Surface\") plt.gca().add_patch(earth_circle) plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Payload Trajectory Near Earth\") plt.legend() plt.axis(\"equal\") plt.grid() plt.show()","title":"Draw Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics. Problem Statement The task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. The waves will be described using the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k \\cdot r - \\omega \\cdot t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude of the wave. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number ( \\(\\lambda\\) is the wavelength). \\(\\omega = 2\\pi \\cdot f\\) is the angular frequency ( \\(f\\) is the frequency). \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source at \\((x_0, y_0)\\) to the point \\((x, y)\\) . \\(\\phi\\) is the initial phase. Steps to Follow 1. Select a Regular Polygon Choose a regular polygon, such as an equilateral triangle, square, or regular pentagon, for the placement of the point sources. 2. Position the Sources Place point wave sources at the vertices of the selected polygon. For example, for an equilateral triangle, there will be three sources, one at each vertex. 3. Wave Equations Write the equations describing the waves emitted from each source, considering their respective positions. 4. Superposition of Waves Apply the principle of superposition by summing the wave displacements at each point on the water surface. The displacement at any point \\((x, y)\\) on the surface is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\(N\\) is the number of sources (vertices of the polygon). 5. Analyze Interference Patterns Examine the resulting displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) as a function of position \\((x, y)\\) and time \\(t\\) . Identify regions of: - Constructive interference (wave amplification) - Destructive interference (wave cancellation) 6. Visualization Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Considerations: - Assume all sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . - The waves are coherent (i.e., they maintain a constant phase difference). Python Code for Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants A = 1 # amplitude lambda_ = 1 # wavelength f = 1 # frequency omega = 2 * np.pi * f # angular frequency k = 2 * np.pi / lambda_ # wave number phi = 0 # initial phase Function to compute the wave displacement at a given point (x, y) and time t def wave(x, y, x0, y0, t): r = np.sqrt((x - x0) 2 + (y - y0) 2) # distance from the source return A / np.sqrt(r) * np.cos(k * r - omega * t + phi) Function to compute the superposition of waves from multiple sources def superposition(x, y, sources, t): displacement = 0 for (x0, y0) in sources: displacement += wave(x, y, x0, y0, t) return displacement Create a grid of points on the water surface x_vals = np.linspace(-5, 5, 200) y_vals = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x_vals, y_vals) Define the number of sources and their positions for a regular polygon (e.g., hexagon) N = 6 # Number of sources (vertices of hexagon) radius = 2 # Radius of the circle on which the sources lie angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(angle), radius * np.sin(angle)) for angle in angles] Time variable for the wave motion t = 0.5 # Arbitrary time value for visualization Compute the displacement on the water surface due to superposition Z = np.vectorize(superposition)(X, Y, sources, t) Plot the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 20, cmap='jet') plt.colorbar(label='Displacement') plt.title('Interference Pattern on Water Surface (t = 0.5)') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"The task is to analyze the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. The waves will be described using the Single Disturbance equation: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k \\cdot r - \\omega \\cdot t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) . \\(A\\) is the amplitude of the wave. \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number ( \\(\\lambda\\) is the wavelength). \\(\\omega = 2\\pi \\cdot f\\) is the angular frequency ( \\(f\\) is the frequency). \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source at \\((x_0, y_0)\\) to the point \\((x, y)\\) . \\(\\phi\\) is the initial phase.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"","title":"Steps to Follow"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-select-a-regular-polygon","text":"Choose a regular polygon, such as an equilateral triangle, square, or regular pentagon, for the placement of the point sources.","title":"1. Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-position-the-sources","text":"Place point wave sources at the vertices of the selected polygon. For example, for an equilateral triangle, there will be three sources, one at each vertex.","title":"2. Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-wave-equations","text":"Write the equations describing the waves emitted from each source, considering their respective positions.","title":"3. Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-superposition-of-waves","text":"Apply the principle of superposition by summing the wave displacements at each point on the water surface. The displacement at any point \\((x, y)\\) on the surface is given by: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Where \\(N\\) is the number of sources (vertices of the polygon).","title":"4. Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-interference-patterns","text":"Examine the resulting displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) as a function of position \\((x, y)\\) and time \\(t\\) . Identify regions of: - Constructive interference (wave amplification) - Destructive interference (wave cancellation)","title":"5. Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualization","text":"Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Considerations: - Assume all sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . - The waves are coherent (i.e., they maintain a constant phase difference).","title":"6. Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-for-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"Python Code for Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#constants","text":"A = 1 # amplitude lambda_ = 1 # wavelength f = 1 # frequency omega = 2 * np.pi * f # angular frequency k = 2 * np.pi / lambda_ # wave number phi = 0 # initial phase","title":"Constants"},{"location":"1%20Physics/3%20Waves/Problem_1/#function-to-compute-the-wave-displacement-at-a-given-point-x-y-and-time-t","text":"def wave(x, y, x0, y0, t): r = np.sqrt((x - x0) 2 + (y - y0) 2) # distance from the source return A / np.sqrt(r) * np.cos(k * r - omega * t + phi)","title":"Function to compute the wave displacement at a given point (x, y) and time t"},{"location":"1%20Physics/3%20Waves/Problem_1/#function-to-compute-the-superposition-of-waves-from-multiple-sources","text":"def superposition(x, y, sources, t): displacement = 0 for (x0, y0) in sources: displacement += wave(x, y, x0, y0, t) return displacement","title":"Function to compute the superposition of waves from multiple sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#create-a-grid-of-points-on-the-water-surface","text":"x_vals = np.linspace(-5, 5, 200) y_vals = np.linspace(-5, 5, 200) X, Y = np.meshgrid(x_vals, y_vals)","title":"Create a grid of points on the water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#define-the-number-of-sources-and-their-positions-for-a-regular-polygon-eg-hexagon","text":"N = 6 # Number of sources (vertices of hexagon) radius = 2 # Radius of the circle on which the sources lie angles = np.linspace(0, 2 * np.pi, N, endpoint=False) sources = [(radius * np.cos(angle), radius * np.sin(angle)) for angle in angles]","title":"Define the number of sources and their positions for a regular polygon (e.g., hexagon)"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-variable-for-the-wave-motion","text":"t = 0.5 # Arbitrary time value for visualization","title":"Time variable for the wave motion"},{"location":"1%20Physics/3%20Waves/Problem_1/#compute-the-displacement-on-the-water-surface-due-to-superposition","text":"Z = np.vectorize(superposition)(X, Y, sources, t)","title":"Compute the displacement on the water surface due to superposition"},{"location":"1%20Physics/3%20Waves/Problem_1/#plot-the-interference-pattern","text":"plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, 20, cmap='jet') plt.colorbar(label='Displacement') plt.title('Interference Pattern on Water Surface (t = 0.5)') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Plot the interference pattern"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 \ud83d\udcd8 Simulating the Effects of the Lorentz Force \ud83c\udfaf Objective To simulate the trajectory of a charged particle under the influence of electric and magnetic fields using the Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\(\\vec{F}\\) is the Lorentz force \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field \\(\\vec{v}\\) is the velocity of the particle \\(\\vec{B}\\) is the magnetic field \ud83e\uddea Simulation Scenarios Magnetic field only ( \\(\\vec{E} = 0\\) ) Combined electric and magnetic fields Crossed electric and magnetic fields \u2699\ufe0f Parameters Particle charge: \\(q = 1.0\\,\\mathrm{C}\\) Particle mass: \\(m = 1.0\\,\\mathrm{kg}\\) Initial position: \\(\\vec{r}_0 = (0, 0, 0)\\) Initial velocity: \\(\\vec{v}_0 = (1, 1, 0)\\) Magnetic field: \\(\\vec{B} = (0, 0, 1)\\,\\mathrm{T}\\) Electric field: configurable \ud83d\udcc8 Deliverables Plot of particle trajectory in 3D Visual exploration of how \\(\\vec{E}\\) , \\(\\vec{B}\\) , \\(q\\) , \\(m\\) , and \\(\\vec{v}_0\\) affect motion Discussion on physical phenomena (Larmor radius, drift velocity) \ud83e\udde0 Methods Euler\u2019s method for numerical integration 3D plotting using matplotlib \ud83d\udc0d Python Code import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge in Coulombs m = 1.0 # mass in kilograms # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field vector (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field vector (T) # Initial conditions r = np.array([0.0, 0.0, 0.0]) # Initial position (m) v = np.array([1.0, 1.0, 0.0]) # Initial velocity (m/s) # Time parameters dt = 0.01 # time step (s) steps = 1000 # total steps # Initialize array to store trajectory trajectory = np.zeros((steps, 3)) # Euler integration loop for i in range(steps): trajectory[i] = r F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v += a * dt # Update velocity r += v * dt # Update position # Plotting fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Charged Particle Trajectory under Lorentz Force') ax.legend() plt.show() \ud83d\udd04 Extensions Replace Euler method with Runge-Kutta for better accuracy Simulate non-uniform fields Include relativistic corrections at high speeds","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"\ud83d\udcd8 Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#objective","text":"To simulate the trajectory of a charged particle under the influence of electric and magnetic fields using the Lorentz force: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\(\\vec{F}\\) is the Lorentz force \\(q\\) is the charge of the particle \\(\\vec{E}\\) is the electric field \\(\\vec{v}\\) is the velocity of the particle \\(\\vec{B}\\) is the magnetic field","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-scenarios","text":"Magnetic field only ( \\(\\vec{E} = 0\\) ) Combined electric and magnetic fields Crossed electric and magnetic fields","title":"\ud83e\uddea Simulation Scenarios"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Particle charge: \\(q = 1.0\\,\\mathrm{C}\\) Particle mass: \\(m = 1.0\\,\\mathrm{kg}\\) Initial position: \\(\\vec{r}_0 = (0, 0, 0)\\) Initial velocity: \\(\\vec{v}_0 = (1, 1, 0)\\) Magnetic field: \\(\\vec{B} = (0, 0, 1)\\,\\mathrm{T}\\) Electric field: configurable","title":"\u2699\ufe0f Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#deliverables","text":"Plot of particle trajectory in 3D Visual exploration of how \\(\\vec{E}\\) , \\(\\vec{B}\\) , \\(q\\) , \\(m\\) , and \\(\\vec{v}_0\\) affect motion Discussion on physical phenomena (Larmor radius, drift velocity)","title":"\ud83d\udcc8 Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#methods","text":"Euler\u2019s method for numerical integration 3D plotting using matplotlib","title":"\ud83e\udde0 Methods"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.0 # charge in Coulombs m = 1.0 # mass in kilograms # Fields E = np.array([0.0, 0.0, 0.0]) # Electric field vector (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field vector (T) # Initial conditions r = np.array([0.0, 0.0, 0.0]) # Initial position (m) v = np.array([1.0, 1.0, 0.0]) # Initial velocity (m/s) # Time parameters dt = 0.01 # time step (s) steps = 1000 # total steps # Initialize array to store trajectory trajectory = np.zeros((steps, 3)) # Euler integration loop for i in range(steps): trajectory[i] = r F = q * (E + np.cross(v, B)) # Lorentz force a = F / m # Acceleration v += a * dt # Update velocity r += v * dt # Update position # Plotting fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], label='Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Charged Particle Trajectory under Lorentz Force') ax.legend() plt.show()","title":"\ud83d\udc0d Python Code"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Replace Euler method with Runge-Kutta for better accuracy Simulate non-uniform fields Include relativistic corrections at high speeds","title":"\ud83d\udd04 Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1: Equivalent Resistance Using Graph Theory Solution Option 1: Algorithm Description Algorithm Overview The algorithm for calculating equivalent resistance using graph theory involves iteratively simplifying the circuit graph by identifying and reducing series and parallel connections until only a single equivalent resistance remains. Key Steps: Graph Representation : Represent the circuit as an undirected weighted graph \\(G = (V, E)\\) where: \\(V\\) = set of nodes (connection points/junctions) \\(E\\) = set of edges (resistors) with weight \\(R_i\\) (resistance value) Series Reduction : Identify nodes with degree 2 (connected to exactly two edges) For such nodes, combine the two resistors in series: \\( \\(R_{eq} = R_1 + R_2\\) \\) Remove the intermediate node and replace with a single edge Parallel Reduction : Identify edges that form parallel connections (multiple edges between same pair of nodes) Combine parallel resistors using: \\( \\(\\frac{1}{R_{eq}} = \\sum_{i=1}^n \\frac{1}{R_i}\\) \\) Replace parallel edges with a single equivalent edge Iterative Simplification : Repeat series and parallel reductions until: Only two nodes remain (source and destination), or No more reductions are possible (complex circuit requiring advanced methods) Pseudocode # Parallel reduction for u, v in graph.edges: parallel_edges = get_all_edges_between(u, v) if count(parallel_edges) > 1: inverse_sum = sum(1/R for R in parallel_edges) Req = 1 / inverse_sum graph.remove_all_edges_between(u, v) graph.add_edge(u, v, Req) if graph has only source and target: return get_edge_resistance(source, target) else: return \"Circuit too complex for simple reduction\" Solution Option 2: Python Implementation ```python def equivalent_resistance(graph, source, target): \"\"\"Calculate equivalent resistance between source and target nodes.\"\"\" G = graph.copy() while True: # Check if we're done if G.number_of_nodes() == 2 and G.number_of_edges() == 1: return next(G.edges(data=True))[2]['weight'] # Series reduction reduced = False for node in list(G.nodes()): if node not in [source, target] and G.degree(node) == 2: neighbors = list(G.neighbors(node)) R1 = G[node][neighbors[0]]['weight'] R2 = G[node][neighbors[1]]['weight'] Req = R1 + R2 G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], weight=Req) reduced = True break if reduced: continue # Parallel reduction for u, v in list(G.edges()): parallel_edges = list(G.get_edge_data(u, v).values()) if len(parallel_edges) > 1: inverse_sum = sum(1/e['weight'] for e in parallel_edges) Req = 1 / inverse_sum G.remove_edges_between(u, v) G.add_edge(u, v, weight=Req) reduced = True break if not reduced: break if G.number_of_nodes() == 2 and G.number_of_edges() == 1: return next(G.edges(data=True))[2]['weight'] else: raise ValueError(\"Circuit too complex for simple reduction\") Example usage if name == \" main \": # Example 1: Simple series circuit G1 = nx.Graph() G1.add_edge('A', 'B', weight=2) G1.add_edge('B', 'C', weight=3) print(\"Example 1 (2+3 series):\", equivalent_resistance(G1, 'A', 'C')) # Example 2: Simple parallel circuit G2 = nx.Graph() G2.add_edge('A', 'B', weight=4) G2.add_edge('A', 'B', weight=4) print(\"Example 2 (4||4 parallel):\", equivalent_resistance(G2, 'A', 'B')) # Example 3: Combined series-parallel G3 = nx.Graph() G3.add_edge('A', 'B', weight=1) G3.add_edge('B', 'C', weight=2) G3.add_edge('B', 'C', weight=2) G3.add_edge('C', 'D', weight=1) print(\"Example 3 (Combined):\", equivalent_resistance(G3, 'A', 'D'))","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#solution-option-1-algorithm-description","text":"","title":"Solution Option 1: Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-overview","text":"The algorithm for calculating equivalent resistance using graph theory involves iteratively simplifying the circuit graph by identifying and reducing series and parallel connections until only a single equivalent resistance remains.","title":"Algorithm Overview"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-steps","text":"Graph Representation : Represent the circuit as an undirected weighted graph \\(G = (V, E)\\) where: \\(V\\) = set of nodes (connection points/junctions) \\(E\\) = set of edges (resistors) with weight \\(R_i\\) (resistance value) Series Reduction : Identify nodes with degree 2 (connected to exactly two edges) For such nodes, combine the two resistors in series: \\( \\(R_{eq} = R_1 + R_2\\) \\) Remove the intermediate node and replace with a single edge Parallel Reduction : Identify edges that form parallel connections (multiple edges between same pair of nodes) Combine parallel resistors using: \\( \\(\\frac{1}{R_{eq}} = \\sum_{i=1}^n \\frac{1}{R_i}\\) \\) Replace parallel edges with a single equivalent edge Iterative Simplification : Repeat series and parallel reductions until: Only two nodes remain (source and destination), or No more reductions are possible (complex circuit requiring advanced methods)","title":"Key Steps:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"# Parallel reduction for u, v in graph.edges: parallel_edges = get_all_edges_between(u, v) if count(parallel_edges) > 1: inverse_sum = sum(1/R for R in parallel_edges) Req = 1 / inverse_sum graph.remove_all_edges_between(u, v) graph.add_edge(u, v, Req) if graph has only source and target: return get_edge_resistance(source, target) else: return \"Circuit too complex for simple reduction\"","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#solution-option-2-python-implementation","text":"```python def equivalent_resistance(graph, source, target): \"\"\"Calculate equivalent resistance between source and target nodes.\"\"\" G = graph.copy() while True: # Check if we're done if G.number_of_nodes() == 2 and G.number_of_edges() == 1: return next(G.edges(data=True))[2]['weight'] # Series reduction reduced = False for node in list(G.nodes()): if node not in [source, target] and G.degree(node) == 2: neighbors = list(G.neighbors(node)) R1 = G[node][neighbors[0]]['weight'] R2 = G[node][neighbors[1]]['weight'] Req = R1 + R2 G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], weight=Req) reduced = True break if reduced: continue # Parallel reduction for u, v in list(G.edges()): parallel_edges = list(G.get_edge_data(u, v).values()) if len(parallel_edges) > 1: inverse_sum = sum(1/e['weight'] for e in parallel_edges) Req = 1 / inverse_sum G.remove_edges_between(u, v) G.add_edge(u, v, weight=Req) reduced = True break if not reduced: break if G.number_of_nodes() == 2 and G.number_of_edges() == 1: return next(G.edges(data=True))[2]['weight'] else: raise ValueError(\"Circuit too complex for simple reduction\")","title":"Solution Option 2: Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-usage","text":"if name == \" main \": # Example 1: Simple series circuit G1 = nx.Graph() G1.add_edge('A', 'B', weight=2) G1.add_edge('B', 'C', weight=3) print(\"Example 1 (2+3 series):\", equivalent_resistance(G1, 'A', 'C')) # Example 2: Simple parallel circuit G2 = nx.Graph() G2.add_edge('A', 'B', weight=4) G2.add_edge('A', 'B', weight=4) print(\"Example 2 (4||4 parallel):\", equivalent_resistance(G2, 'A', 'B')) # Example 3: Combined series-parallel G3 = nx.Graph() G3.add_edge('A', 'B', weight=1) G3.add_edge('B', 'C', weight=2) G3.add_edge('B', 'C', weight=2) G3.add_edge('C', 'D', weight=1) print(\"Example 3 (Combined):\", equivalent_resistance(G3, 'A', 'D'))","title":"Example usage"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}